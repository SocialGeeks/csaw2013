# Exploitation - Exploitation 2 - 200 Points  

## Challenge site  

nc 128.238.66.212 31338  
exploit2  

## Server output  

Welcome to CSAW CTF.  Exploitation 2 will be a little harder this year.  Insert your exploit here:  

## Notes  

	$ file exploit2  
	exploit2: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=94f196c7d8ce45ecf9943690ed4e193c9d13b906, not stripped  

	gdb example to spot buffer overrun:
	------------------------------------
	$ gdb exploit2
	(gdb) set follow-fork-mode child
	(gdb) break *0x80488f5
	(gdb) run
	$ python -c "print('A'*3000)" | nc localhost 31338
	hit at breakpoint 0x80488f5
	(gdb) next
	frame 1 # <- if you overran you should see your pattern (example: 0x41414141)
	
	
	Things i have learned.
	The stack frame pattern is at offset 2064
	but there is a stack cookie at offset 2048
	The garbage at the begining of the message (ie; ',uyye!w-Welcome to CSAW CTF. ') is not just crap. 
	    at offset 4 is the stack cookie (4 byte integer big endian).
	That stack cookie can also be read out of memory in GDB at memory offset 0x804a074
	
	All the data you need to beat this is sent to you:
	00000000  1c d3 ff ff f7 cd c1 6a  57 65 6c 63 6f 6d 65 20  |.......jWelcome |
	00000010  74 6f 20 43 53 41 57 20  43 54 46 2e 20 20 45 78  |to CSAW CTF.  Ex|
	00000020  70 6c 6f 69 74 61 74 69  6f 6e 20 32 20 77 69 6c  |ploitation 2 wil|
	00000030  6c 20 62 65 20 61 20 6c  69 74 74 6c 65 20 68 61  |l be a little ha|
	00000040  72 64 65 72 20 74 68 69  73 20 79 65 61 72 2e 20  |rder this year. |
	00000050  20 49 6e 73 65 72 74 20  79 6f 75 72 20 65 78 70  | Insert your exp|
	00000060  6c 6f 69 74 20 68 65 72  65 3a 00                 |loit here:.|
	0000006b

	The first 4 bytes of data is the location of the buffer. 
	The next 4 bytes of data is the stack cookie.

	The solution is to put your shell code at the beging of the buffer and seed the stack cookie and the RET address in the return.

